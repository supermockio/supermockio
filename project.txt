import { Module } from "@nestjs/common"
import { MongooseModule } from "@nestjs/mongoose"
import { ConfigService } from "./config/config.service"
import { ConfigModule } from "./config/config.module"
import { Service, ServiceSchema } from "./schemas/service.schema"
import { ServiceService } from "./services/service.service"
import { ResponseService } from "./services/response.service"
import { Response, ResponseSchema } from "./schemas/response.schema"
import { ServiceController } from "./controllers/service.controller"
import { MockerController } from "./controllers/mocker.controller"
import { GeminiService } from "./services/GeminiService"
import { AuthModule } from "./auth/auth.module"
import { User, UserSchema } from "./schemas/user.schema"
import { CollaboratorService } from "./services/collaborator.service"
import { CollaboratorController } from "./controllers/collaborator.controller"
import { ServicePermissionGuard } from "./auth/guards/service-permission.guard"

@Module({
  imports: [
    ConfigModule,
    // MongoDB Connection Config
    MongooseModule.forRoot(new ConfigService().getMongoConfig()),
    // Service Schema DB config
    MongooseModule.forFeature([{ name: Service.name, schema: ServiceSchema }]),
    // Response Schema DB config
    MongooseModule.forFeature([{ name: Response.name, schema: ResponseSchema }]),
    // User Schema DB config
    MongooseModule.forFeature([{ name: User.name, schema: UserSchema }]),
    // Auth Module
    AuthModule,
  ],
  controllers: [ServiceController, MockerController, CollaboratorController],
  providers: [ServiceService, ResponseService, GeminiService, CollaboratorService, ServicePermissionGuard],
})
export class AppModule {}


import { Body, Controller, Post, UseGuards, Request } from "@nestjs/common"
import { ApiTags, ApiOperation, ApiResponse } from "@nestjs/swagger"
import { LoginDto, RegisterDto } from "src/dtos/auth.dto"
import { AuthService } from "./auth.service"
import { LocalAuthGuard } from "./guards/local-auth.guard"

@ApiTags("auth")
@Controller("api/auth")
export class AuthController {
  constructor(private authService: AuthService) {}

  @Post('register')
  @ApiOperation({ summary: 'Register a new user' })
  @ApiResponse({ status: 201, description: 'User successfully registered' })
  @ApiResponse({ status: 409, description: 'User already exists' })
  async register(@Body() registerDto: RegisterDto) {
    return this.authService.register(registerDto);
  }

  @UseGuards(LocalAuthGuard)
  @Post("login")
  @ApiOperation({ summary: "Login with email and password" })
  @ApiResponse({ status: 200, description: "User successfully logged in" })
  @ApiResponse({ status: 401, description: "Invalid credentials" })
  async login(@Request() req, @Body() loginDto: LoginDto) {
    return this.authService.login(req.user)
  }
}


import { Module } from "@nestjs/common"
import { JwtModule } from "@nestjs/jwt"
import { MongooseModule } from "@nestjs/mongoose"
import { PassportModule } from "@nestjs/passport"
import { User, UserSchema } from "src/schemas/user.schema"
import { AuthController } from "./auth.controller"
import { AuthService } from "./auth.service"
import { JwtStrategy } from "./strategies/jwt.strategy"
import { LocalStrategy } from "./strategies/local.strategy"

@Module({
  imports: [
    PassportModule,
    JwtModule.register({
      secret: process.env.JWT_SECRET || "defaultsecret", // Use environment variable or fallback
      signOptions: { expiresIn: "1d" },
    }),
    MongooseModule.forFeature([{ name: User.name, schema: UserSchema }]),
  ],
  controllers: [AuthController],
  providers: [AuthService, LocalStrategy, JwtStrategy],
  exports: [AuthService],
})
export class AuthModule {}


import { Injectable, ConflictException, UnauthorizedException } from "@nestjs/common"
import { JwtService } from "@nestjs/jwt"
import { InjectModel } from "@nestjs/mongoose"
import { Model } from "mongoose"
import * as bcrypt from "bcrypt"
import { User, type UserDocument } from "src/schemas/user.schema"
import { JwtPayload, RegisterDto } from "src/dtos/auth.dto"

@Injectable()
export class AuthService {
  constructor(
    @InjectModel(User.name) private userModel: Model<UserDocument>,
    private jwtService: JwtService,
  ) {}

  async register(registerDto: RegisterDto): Promise<{ access_token: string }> {
    const { username, email, password } = registerDto

    // Check if user already exists
    const existingUser = await this.userModel.findOne({
      $or: [{ email }, { username }],
    })

    if (existingUser) {
      throw new ConflictException("User with this email or username already exists")
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10)

    // Create new user
    const newUser = await this.userModel.create({
      username,
      email,
      password: hashedPassword,
      roles: ["user"],
    })

    // Generate JWT token
    return this.generateToken(newUser)
  }

  async validateUser(email: string, password: string): Promise<User> {
    const user = await this.userModel.findOne({ email })

    if (!user) {
      throw new UnauthorizedException("Invalid credentials")
    }

    const isPasswordValid = await bcrypt.compare(password, user.password)

    if (!isPasswordValid) {
      throw new UnauthorizedException("Invalid credentials")
    }

    return user
  }

  async login(user: User): Promise<{ access_token: string }> {
    return this.generateToken(user)
  }

  private generateToken(user: User): { access_token: string } {
    const payload: JwtPayload = {
      sub: user._id.toString(),
      username: user.username,
      email: user.email,
      roles: user.roles,
    }

    return {
      access_token: this.jwtService.sign(payload),
    }
  }
}


import { SetMetadata } from "@nestjs/common"

export const Permission = (permission: string) => SetMetadata("permission", permission)


import { SetMetadata } from "@nestjs/common"

export const Roles = (...roles: string[]) => SetMetadata("roles", roles)


import { Injectable } from "@nestjs/common"
import { AuthGuard } from "@nestjs/passport"

@Injectable()
export class JwtAuthGuard extends AuthGuard("jwt") {}


import { Injectable } from "@nestjs/common"
import { AuthGuard } from "@nestjs/passport"

@Injectable()
export class LocalAuthGuard extends AuthGuard("local") {}


import { Injectable, type CanActivate, type ExecutionContext } from "@nestjs/common"
import { Reflector } from "@nestjs/core"
import { Observable } from "rxjs"

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean | Promise<boolean> | Observable<boolean> {
    const requiredRoles = this.reflector.get<string[]>("roles", context.getHandler())
    if (!requiredRoles) {
      return true
    }

    const { user } = context.switchToHttp().getRequest()
    return requiredRoles.some((role) => user.roles?.includes(role))
  }
}


import { Injectable, type CanActivate, type ExecutionContext, HttpException, HttpStatus } from "@nestjs/common"
import { Reflector } from "@nestjs/core"
import { CollaboratorService } from "src/services/collaborator.service"
import { ServiceService } from "src/services/service.service"

@Injectable() 
export class ServicePermissionGuard implements CanActivate {
  constructor(
    private reflector: Reflector,
    private serviceService: ServiceService,
    private collaboratorService: CollaboratorService,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const requiredPermission = this.reflector.get<string>("permission", context.getHandler())
    if (!requiredPermission) {
      return true
    }

    const request = context.switchToHttp().getRequest()
    const user = request.user
    const params = request.params

    // Get service by name and version
    const name = decodeURIComponent(params.name)
    const version = decodeURIComponent(params.version)
    const service = await this.serviceService.findOneByNameAndVersion(name, version)

    if (!service) {
      throw new HttpException("Service not found", HttpStatus.NOT_FOUND)
    }

    // Check if user is owner
    const isOwner = await this.collaboratorService.isOwner(service._id, user.userId)
    if (isOwner) {
      return true
    }

    // If permission is 'view', check if user is a collaborator
    if (requiredPermission === "view") {
      const isCollaborator = await this.collaboratorService.isCollaborator(service._id, user.userId)
      return isCollaborator
    }

    // For 'delete' or other permissions, only owner is allowed
    return false
  }
}


import { Injectable } from "@nestjs/common"
import { PassportStrategy } from "@nestjs/passport"
import { ExtractJwt, Strategy } from "passport-jwt"
import { ConfigService } from "src/config/config.service"
import { JwtPayload } from "src/dtos/auth.dto"

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(private configService: ConfigService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: process.env.JWT_SECRET || "defaultsecret", // Use environment variable or fallback
    })
  }

  async validate(payload: JwtPayload) {
    return {
      userId: payload.sub,
      username: payload.username,
      email: payload.email,
      roles: payload.roles,
    }
  }
}


import { Injectable, UnauthorizedException } from "@nestjs/common"
import { PassportStrategy } from "@nestjs/passport"
import { Strategy } from "passport-local"
import { AuthService } from "../auth.service"

@Injectable()
export class LocalStrategy extends PassportStrategy(Strategy) {
  constructor(private authService: AuthService) {
    super({ usernameField: "email" })
  }

  async validate(email: string, password: string) {
    const user = await this.authService.validateUser(email, password)
    if (!user) {
      throw new UnauthorizedException("Invalid credentials")
    }
    return user
  }
}


import { Global, Module } from '@nestjs/common';

import { ConfigService } from './config.service';

@Global()
@Module({
    providers: [
        {
            provide: ConfigService,
            useValue: new ConfigService(),
        },
    ],
    exports: [ConfigService],
})
export class ConfigModule { }
import * as dotenv from 'dotenv';

export class ConfigService {
    private readonly envConfig: Record<string, string>;
    constructor() {
        const result = dotenv.config();

        if (result.error) {
            this.envConfig = process.env;
        } else {
            this.envConfig = result.parsed;
        }
    }

    public get(key: string): string {
        return this.envConfig[key];
    }

    public async getPortConfig() {
        return this.get('PORT');
    }

    public getMongoConfig() {
        return this.get("MONGO_PROTOCOL") + '://' + this.get('MONGO_USER') + ':' + this.get('MONGO_PASSWORD') + '@' + this.get('MONGO_HOST') + '/' + this.get('MONGO_DATABASE')

    }
}
import {
    Body,
    Controller,
    Delete,
    Get,
    HttpException,
    HttpStatus,
    Param,
    Post,
    Request,
    UseGuards,
  } from "@nestjs/common"
  import { ApiOperation, ApiResponse, ApiTags } from "@nestjs/swagger"
  import { JwtAuthGuard } from "src/auth/guards/jwt-auth.guard"
  import { AddCollaboratorDto, RemoveCollaboratorDto } from "src/dtos/collaborator.dto"
  import { ServiceService } from "src/services/service.service"
  import { CollaboratorService } from "src/services/collaborator.service"
  import { MockerResponse } from "src/utils/MockerResponse"
import { Permission } from "src/auth/decorators/permission.decorator"
import { ServicePermissionGuard } from "src/auth/guards/service-permission.guard"
  
  @ApiTags("collaborators")
  @Controller("/api/services/:name/:version/collaborators")
  @UseGuards(JwtAuthGuard)
  export class CollaboratorController {
    constructor(
      private readonly serviceService: ServiceService,
      private readonly collaboratorService: CollaboratorService,
    ) {}
  
    @Get()
    @UseGuards(ServicePermissionGuard)
    @Permission("view")
    @ApiOperation({ summary: "Get all collaborators for a service" })
    @ApiResponse({
      status: 200,
      description: "List of collaborators for the service",
    })
    async getCollaborators(@Param("name") name: string, @Param("version") version: string, @Request() req) {
      name = decodeURIComponent(name)
      version = decodeURIComponent(version)
  
      const service = await this.serviceService.findOneByNameAndVersion(name, version)
      if (!service) {
        throw new HttpException("Service not found", HttpStatus.NOT_FOUND)
      }
  
      return this.collaboratorService.getCollaborators(service._id)
    }
  
    @Post()
    @ApiOperation({ summary: "Add a collaborator to a service" })
    @ApiResponse({
      status: 201,
      description: "Collaborator added successfully",
      type: MockerResponse,
    })
    async addCollaborator(
      @Param("name") name: string,
      @Param("version") version: string,
      @Body() addCollaboratorDto: AddCollaboratorDto,
      @Request() req,
    ) {
      name = decodeURIComponent(name)
      version = decodeURIComponent(version)
  
      const service = await this.serviceService.findOneByNameAndVersion(name, version)
      if (!service) {
        throw new HttpException("Service not found", HttpStatus.NOT_FOUND)
      }
  
      // Check if user is owner
      const userId = req.user.userId
      if (service.owner.toString() !== userId) {
        throw new HttpException("Only the owner can add collaborators", HttpStatus.FORBIDDEN)
      }
  
      await this.collaboratorService.addCollaborator(service._id, addCollaboratorDto.email)
      return new MockerResponse(201, "Collaborator added successfully")
    }
  
    @Delete()
    @ApiOperation({ summary: "Remove a collaborator from a service" })
    @ApiResponse({
      status: 200,
      description: "Collaborator removed successfully",
      type: MockerResponse,
    })
    async removeCollaborator(
      @Param("name") name: string,
      @Param("version") version: string,
      @Body() removeCollaboratorDto: RemoveCollaboratorDto,
      @Request() req,
    ) {
      name = decodeURIComponent(name)
      version = decodeURIComponent(version)
  
      const service = await this.serviceService.findOneByNameAndVersion(name, version)
      if (!service) {
        throw new HttpException("Service not found", HttpStatus.NOT_FOUND)
      }
  
      // Check if user is owner
      const userId = req.user.userId
      if (service.owner.toString() !== userId) {
        throw new HttpException("Only the owner can remove collaborators", HttpStatus.FORBIDDEN)
      }
  
      await this.collaboratorService.removeCollaborator(service._id, removeCollaboratorDto.email)
      return new MockerResponse(200, "Collaborator removed successfully")
    }
  }
  
  
import { All, Controller, Headers, HttpException, HttpStatus, Param, Req, Res, UseGuards } from "@nestjs/common"
import { ApiExcludeController } from "@nestjs/swagger"
import { Request, Response } from "express"
import { JwtAuthGuard } from "src/auth/guards/jwt-auth.guard"
import { ResponseService } from "src/services/response.service"
import { ServiceService } from "src/services/service.service"
import { CollaboratorService } from "src/services/collaborator.service"

@ApiExcludeController()
@Controller("/api/mocks/:name/:version/*")
@UseGuards(JwtAuthGuard)
export class MockerController {
  constructor(
    private readonly responseService: ResponseService,
    private readonly serviceService: ServiceService,
    private readonly collaboratorService: CollaboratorService,
  ) {}

  @All()
  async handleMocks(
    @Req() request: Request,
    @Param() params: string[],
    @Res() res: Response,
    @Headers("X-SuperMockio-Status") hdrStatus: number,
    @Headers("X-SuperMockio-Example") exampleName?: string,
  ) {
    const responseCriteria = {
      method: request.method.toLowerCase(),
      path: "/" + request.path.split("/").slice(5).join("/"),
      name: decodeURIComponent(params["name"]),
      version: decodeURIComponent(params["version"]),
    }

    const service = await this.serviceService.findOneByNameAndVersion(responseCriteria.name, responseCriteria.version)
    if (!service) {
      throw new HttpException("The service cannot be found", HttpStatus.NOT_FOUND)
    }

    // Check if user has access to this service
    const userId = request.user["userId"]
    const isOwner = await this.collaboratorService.isOwner(service._id, userId)
    const isCollaborator = await this.collaboratorService.isCollaborator(service._id, userId)

    if (!isOwner && !isCollaborator) {
      throw new HttpException("Unauthorized access to this service", HttpStatus.FORBIDDEN)
    }

    let fetchedRes = await this.responseService.findOneByServiceCriteria(
      service._id,
      responseCriteria.path,
      responseCriteria.method,
      hdrStatus,
      exampleName,
    )

    // Check the new env var to decide behavior.
    const strictMode = process.env.MOCKER_STRICT_MODE === "true"
    if (!fetchedRes) {
      if (strictMode) {
        const errorMessage = `The request endpoint is not defined in this service with the following criteria: statusCode = ${hdrStatus || "N/A"}, exampleName = ${exampleName || "N/A"}.`
        throw new HttpException(errorMessage, HttpStatus.NOT_FOUND)
      } else {
        // Fallback: return a random response for the endpoint.
        fetchedRes = await this.responseService.findRandomResponseByEndpoint(
          service._id,
          responseCriteria.path,
          responseCriteria.method,
        )
        if (!fetchedRes) {
          throw new HttpException("No response defined for this endpoint", HttpStatus.NOT_FOUND)
        }
      }
    }

    res.status(fetchedRes.statusCode).json(fetchedRes.content)
  }
}


import {
  Controller,
  Delete,
  Get,
  HttpException,
  HttpStatus,
  Param,
  Post,
  Query,
  UploadedFile,
  UseGuards,
  UseInterceptors,
  Request,
} from "@nestjs/common"
import { ServiceService } from "src/services/service.service"
import { createServiceDto } from "src/dtos/createServiceDto"
import { ResponseService } from "src/services/response.service"
import { FileInterceptor } from "@nestjs/platform-express"
import { parse } from "yaml"
import { MockerResponse } from "src/utils/MockerResponse"
import { ApiBody, ApiConsumes, ApiResponse, ApiTags } from "@nestjs/swagger"
import { FileUploadDto } from "src/dtos/FileUploadDto"
import { Service } from "src/schemas/service.schema"
import { Response } from "src/schemas/response.schema"
import { JwtAuthGuard } from "src/auth/guards/jwt-auth.guard"
import { Express } from "express"
import { Permission } from "src/auth/decorators/permission.decorator"
import { ServicePermissionGuard } from "src/auth/guards/service-permission.guard"

@ApiTags("services")
@Controller("/api/services")
@UseGuards(JwtAuthGuard)
export class ServiceController {
  constructor(
    private readonly serviceService: ServiceService,
    private readonly responseService: ResponseService,
  ) {}

  @Get()
  @ApiResponse({
    status: 200,
    description: "List of services.",
    type: Service,
    example: [
      new Service("635sqsdd1587", "Test Service", "1.0.0", "Description here", {
        info: { title: "Test Service", version: "1.0.0" },
        paths: {
          "/tests": {},
        },
      }),
    ],
  })
  async getAllServices(@Request() req): Promise<Service[]> {
    // Get services where user is owner or collaborator
    return await this.serviceService.findAllForUser(req.user.userId)
  }

  @Get("/:name/:version")
  @UseGuards(ServicePermissionGuard)
  @Permission("view")
  async getServiceResponses(
    @Param("name") name: string,
    @Param("version") version: string,
  ): Promise<{ service: Service; responses: Response[] }> {
    name = decodeURIComponent(name)
    version = decodeURIComponent(version)

    const service = await this.serviceService.findOneByNameAndVersion(name, version)
  
    if (!service) throw new HttpException("The service cannot be found", HttpStatus.NOT_FOUND)
    const responses = await this.responseService.findByService(service._id)
    return { service, responses }
  }

  @ApiResponse({
    status: 200,
    description: "The OpenAPI specification for the specified service",
    schema: {
      example: {
        openapi: "3.0.0",
        info: { title: "My Service", version: "1.0.0", description: "Sample service" },
        paths: {},
      },
    },
  })
  @Get("/spec/:name/:version")
  @UseGuards(ServicePermissionGuard)
  @Permission("view")
  async getServiceSpec(@Param("name") name: string, @Param("version") version: string): Promise<any> {
    name = decodeURIComponent(name)
    version = decodeURIComponent(version)
    const service = await this.serviceService.findOneByNameAndVersion(name, version)
    if (!service) {
      throw new HttpException("The service cannot be found", HttpStatus.NOT_FOUND)
    }
    // Return only the openapi field
    return { openapi: service.openapi }
  }

  @ApiResponse({
    status: 200,
    description: "Delete a service and it's responses",
    type: MockerResponse,
    example: new MockerResponse(200, "Responses Deleted successfully"),
  })
  @Delete("/:name/:version")
  @UseGuards(ServicePermissionGuard)
  @Permission("delete")
  async deleteServicesResponses(@Param("name") name: string, @Param("version") version: string): Promise<any> {
    name = decodeURIComponent(name)
    version = decodeURIComponent(version)
    const service = await this.serviceService.findOneByNameAndVersion(name, version)
    if (!service) throw new HttpException("Service doesn't exists", HttpStatus.NOT_FOUND)
    await this.responseService.deleteByService(service._id)
    await this.serviceService.delete(service._id)
    return new MockerResponse(200, "Responses Deleted successfully")
  }

  @Post()
  @UseInterceptors(FileInterceptor("file"))
  @ApiConsumes("multipart/form-data")
  @ApiBody({
    description: "openapi file",
    type: FileUploadDto,
  })
  @ApiResponse({
    status: 201,
    description: "The service has been successfully created.",
    type: MockerResponse,
    example: new MockerResponse(201, {
      message: "Service added successfully",
      service: {
        name: "Test Service",
        version: "1.0.0",
      },
    }),
  })
  async createService(
    @UploadedFile() file: Express.Multer.File,
    @Query("override") override: number = 0,
    @Request() req,
  ): Promise<any> {
    const newService = new createServiceDto()
    newService.openapi = parse(file.buffer.toString())
    const exist = await this.serviceService.findOneByNameAndVersion(
      newService.openapi.info.title,
      newService.openapi.info.version,
    )
    // override query param used to override an existing service
    if (override == 0 && exist) {
      if (exist) throw new HttpException("Service already exists", HttpStatus.CONFLICT)
    } else if (exist) {
      // Check if user is the owner before allowing override
      if (exist.owner.toString() !== req.user.userId) {
        throw new HttpException("Only the owner can override a service", HttpStatus.FORBIDDEN)
      }

      // delete the service and its responses if override != 0 and service exists
      await this.responseService.deleteByService(exist._id)
      await this.serviceService.delete(exist._id)
    }
    // persist service if it doesn't exist
    newService.name = newService.openapi.info.title
    newService.version = newService.openapi.info.version
    newService.description = newService.openapi.info.description ?? "-"

    // Set the current user as the owner
    newService.owner = req.user.userId

    const createdService = await this.serviceService.create(newService)
    if (!createdService) throw new HttpException("Error while adding the service", HttpStatus.INTERNAL_SERVER_ERROR)
    // save responses in DB with the new schema
    await this.serviceService.createServiceResponses(createdService)

    return new MockerResponse(201, {
      message: "Service added successfully",
      service: {
        name: createdService.name,
        version: createdService.version,
      },
    })
  }
}


import { ApiProperty } from "@nestjs/swagger"
import { IsEmail, IsNotEmpty, IsString, MinLength } from "class-validator"

export class RegisterDto {
  @ApiProperty({ example: "johndoe" })
  @IsString()
  @IsNotEmpty()
  username: string

  @ApiProperty({ example: "john@example.com" })
  @IsEmail()
  @IsNotEmpty()
  email: string

  @ApiProperty({ example: "Password123!" })
  @IsString()
  @MinLength(8)
  password: string
}

export class LoginDto {
  @ApiProperty({ example: "john@example.com" })
  @IsEmail()
  @IsNotEmpty()
  email: string

  @ApiProperty({ example: "Password123!" })
  @IsString()
  @IsNotEmpty()
  password: string
}

export class JwtPayload {
  sub: string
  username: string
  email: string
  roles: string[]
}


import { ApiProperty } from "@nestjs/swagger"
import { IsEmail, IsNotEmpty } from "class-validator"

export class AddCollaboratorDto {
  @ApiProperty({ example: "john@example.com", description: "Email of the user to add as collaborator" })
  @IsEmail()
  @IsNotEmpty()
  email: string
}

export class RemoveCollaboratorDto {
  @ApiProperty({ example: "john@example.com", description: "Email of the collaborator to remove" })
  @IsEmail()
  @IsNotEmpty()
  email: string
}


import { Service } from "src/schemas/service.schema";
import { createServiceDto } from "./createServiceDto";
import mongoose from "mongoose";

export class CreateResponseDto {
    statusCode: number;
    content: object;
    service: createServiceDto | Service | mongoose.Types.ObjectId;
    path: string;
    method: string;
    exampleName?: string;
}

import { Types } from "mongoose"

export class createServiceDto {
  name: string
  version: string
  description: string
  openapi: any
  owner: Types.ObjectId | string
  collaborators?: (Types.ObjectId | string)[]
}


import { ApiProperty } from "@nestjs/swagger";

export class FileUploadDto {
    @ApiProperty({ type: 'string', format: 'binary' })
    file: any;
  }
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { exit } from 'process';
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';
import { NestExpressApplication } from '@nestjs/platform-express';
import { join } from 'path';


async function bootstrap() {
  if (!process.env['MONGO_PASSWORD'] || !process.env['MONGO_USER'] || !process.env['MONGO_HOST'] || !process.env['MONGO_DATABASE']) {
    console.error("You need to set the required environment variables");
    console.error(`- MONGO_USER
- MONGO_HOST
- MONGO_PASSWORD
- MONGO_DATABASE
- AI_GENERATION_ENABLED`);
    exit(1)
    
  }
  const app = await NestFactory.create<NestExpressApplication>(AppModule);

  app.enableCors({
    origin: '*'
  });


  
  const config = new DocumentBuilder()
  .setTitle('SuperMockio')
  .setDescription(`SuperMockio is a powerful tool designed to accelerate API development by generating mock backends directly from OpenAPI specifications. 
   \n Whether you're an API designer, frontend or backend developer, or project manager. 
   \n SuperMockio empowers you to create realistic mock APIs for various use cases, such as client demos, decoupling frontend and backend development, or testing API integrations`)
  .setVersion('1.0.0')
  .addTag('services')
  .addServer('http://supermockio.io')
  .build();
  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('api-doc', app, document, {
    yamlDocumentUrl: "swagger/yaml"
  });

  await app.listen(process.env.PORT || 3000);
}
bootstrap();

import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import mongoose, { HydratedDocument } from 'mongoose';
import { Service } from './service.schema';
import { ApiProperty } from '@nestjs/swagger';

export type ResponseDocument = HydratedDocument<Response>;

@Schema()
export class Response {
  @ApiProperty()
  @Prop()
  statusCode: number;

  @ApiProperty()
  @Prop({ type: "object" })
  content: object;

  @ApiProperty()
  @Prop({ type: mongoose.Schema.Types.ObjectId, ref: 'Service' })
  service: Service;

  @ApiProperty()
  @Prop()
  path: string;
  
  @ApiProperty()
  @Prop()
  method: string;

  @ApiProperty({ required: false, description: 'Name of the example (if applicable)' })
  @Prop({ required: false })
  exampleName?: string;
}

export const ResponseSchema = SchemaFactory.createForClass(Response);

import { Prop, Schema, SchemaFactory } from "@nestjs/mongoose"
import { ApiProperty } from "@nestjs/swagger"
import mongoose, { type HydratedDocument, Types } from "mongoose"
import { User } from "./user.schema"

export type ServiceDocument = HydratedDocument<Service>

@Schema()
export class Service {
  _id: Types.ObjectId

  @ApiProperty()
  @Prop()
  name: string

  @ApiProperty()
  @Prop()
  version: string

  @ApiProperty()
  @Prop()
  description: string

  @ApiProperty()
  @Prop({ type: "object" })
  openapi: object

  @ApiProperty({ description: "The user who owns this service" })
  @Prop({ type: mongoose.Schema.Types.ObjectId, ref: "User", required: true })
  owner: User | Types.ObjectId

  @ApiProperty({ description: "Users who can view this service" })
  @Prop({ type: [{ type: mongoose.Schema.Types.ObjectId, ref: "User" }], default: [] })
  collaborators: (Types.ObjectId)[]

  constructor(id, name, version, description, openapi) {
    this._id = id
    this.name = name
    this.openapi = openapi
    this.version = version
    this.description = description
  }
}

export const ServiceSchema = SchemaFactory.createForClass(Service)


import { Prop, Schema, SchemaFactory } from "@nestjs/mongoose"
import { ApiProperty } from "@nestjs/swagger"
import { HydratedDocument, Types } from "mongoose"

export type UserDocument = HydratedDocument<User>

@Schema()
export class User {
  _id: Types.ObjectId

  @ApiProperty()
  @Prop({ required: true, unique: true })
  username: string

  @ApiProperty()
  @Prop({ required: true, unique: true })
  email: string

  @ApiProperty()
  @Prop({ required: true })
  password: string

  @ApiProperty()
  @Prop({ default: ["user"] })
  roles: string[]

  @ApiProperty()
  @Prop({ default: Date.now })
  createdAt: Date
}

export const UserSchema = SchemaFactory.createForClass(User)


import { Injectable, HttpException, HttpStatus } from "@nestjs/common"
import { InjectModel } from "@nestjs/mongoose"
import { Model, Types } from "mongoose"
import { Service } from "src/schemas/service.schema"
import { User } from "src/schemas/user.schema"

@Injectable()
export class CollaboratorService {
  constructor(
    @InjectModel(Service.name) private readonly serviceModel: Model<Service>,
    @InjectModel(User.name) private readonly userModel: Model<User>
  ) {}

  async getCollaborators(serviceId: Types.ObjectId) {
    const service = await this.serviceModel.findById(serviceId).populate("collaborators", ["username", "email"]).exec()

    if (!service) {
      throw new HttpException("Service not found", HttpStatus.NOT_FOUND)
    }

    return service.collaborators
  }

  async addCollaborator(serviceId: Types.ObjectId, email: string) {
    // Find the user by email
    const user = await this.userModel.findOne({ email }).exec()
    if (!user) {
      throw new HttpException("User not found", HttpStatus.NOT_FOUND)
    }

    const service = await this.serviceModel.findById(serviceId).exec()
    if (!service) {
      throw new HttpException("Service not found", HttpStatus.NOT_FOUND)
    }

    // Check if user is already a collaborator
    if (service.collaborators.some((collab) => collab.toString() === user._id.toString())) {
      throw new HttpException("User is already a collaborator", HttpStatus.CONFLICT)
    }

    // Check if user is the owner
    if (service.owner.toString() === user._id.toString()) {
      throw new HttpException("Owner cannot be added as a collaborator", HttpStatus.CONFLICT)
    }

    // Add user to collaborators
    service.collaborators.push(user._id)
    await service.save()

    return service
  }

  async removeCollaborator(serviceId: Types.ObjectId, email: string) {
    // Find the user by email
    const user = await this.userModel.findOne({ email }).exec()
    if (!user) {
      throw new HttpException("User not found", HttpStatus.NOT_FOUND)
    }

    const service = await this.serviceModel.findById(serviceId).exec()
    if (!service) {
      throw new HttpException("Service not found", HttpStatus.NOT_FOUND)
    }

    // Check if user is a collaborator
    const collaboratorIndex = service.collaborators.findIndex((collab) => collab.toString() === user._id.toString())

    if (collaboratorIndex === -1) {
      throw new HttpException("User is not a collaborator", HttpStatus.NOT_FOUND)
    }

    // Remove user from collaborators
    service.collaborators.splice(collaboratorIndex, 1)
    await service.save()

    return service
  }

  async isCollaborator(serviceId: Types.ObjectId, userId: string): Promise<boolean> {
    const service = await this.serviceModel.findById(serviceId).exec()
    if (!service) {
      return false
    }

    return service.collaborators.some((collab) => collab.toString() === userId)
  }

  async isOwner(serviceId: Types.ObjectId, userId: string): Promise<boolean> {
    const service = await this.serviceModel.findById(serviceId).exec()
    if (!service) {
      return false
    }

    return service.owner.toString() === userId
  }
}


import { GoogleGenerativeAI, GenerativeModel } from "@google/generative-ai"
import { Injectable } from "@nestjs/common"
import { RateLimiter } from "limiter"
import { AIServiceInterface } from "src/utils/AIServiceInterface"


@Injectable()
export class GeminiService implements AIServiceInterface {
    private model: GenerativeModel
    private rateLimiter: RateLimiter

    private getModel() {
        if (!this.model)
            this.model = new GoogleGenerativeAI(process.env['GEMINI_API_KEY']).getGenerativeModel({ model: "gemini-1.5-flash"})
        return this.model 
    }

    private getRateLimiter() {
        if (!this.rateLimiter)
            this.rateLimiter = new RateLimiter({ tokensPerInterval: 15, interval: "min" })
        return this.rateLimiter
    }

    private cleanJson(response) {
        // Remove markdown annotations
        const cleanedResponse = response.replace(/```json|```/g, '');
      
        // Parse the cleaned JSON string
        const jsonData = JSON.parse(cleanedResponse);
      
        return jsonData;
      }


    public async ask(prompt: string) : Promise<any> {
        await this.getRateLimiter().removeTokens(1)
        const result = await this.getModel().generateContent(prompt)
        const response = result.response;
        const text = this.cleanJson(response.text().trim());
        return text
    }
}
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { CreateResponseDto } from 'src/dtos/createResponseDto';
import { Response } from 'src/schemas/response.schema';



@Injectable()
export class ResponseService {
  constructor(@InjectModel(Response.name) private readonly responseModel: Model<Response>) {}

  async create(createResponseDto: CreateResponseDto): Promise<Response> {
    const createdResponse = await this.responseModel.create(createResponseDto);
    return createdResponse;
  }

  async findAll(): Promise<Response[]> {
    return this.responseModel.find().exec();
  }

  async findOne(id: string): Promise<Response> {
    return this.responseModel.findOne({ _id: id }).populate('service', ["name"]).exec();
  }

  async findOneByNamePopulated(name: number): Promise<Response> {
    return (await this.responseModel.findOne({ statusCode: name }).populate("service").exec());
  }

  async findOneByServiceCriteria(
    serviceId: Types.ObjectId, 
    path: string, 
    method: string, 
    statusCode?: number, 
    exampleName?: string
  ): Promise<Response> {
    const query: any = { service: serviceId, path, method };
    if (statusCode) {
      query.statusCode = statusCode;
    }
    if (exampleName) {
      query.exampleName = exampleName;
    }
    return await this.responseModel.findOne(query).exec();
  }

  async findRandomResponseByEndpoint(
    serviceId: Types.ObjectId, 
    path: string, 
    method: string
  ): Promise<Response> {
    const responses = await this.responseModel.find({ service: serviceId, path, method }).exec();
    if (!responses || responses.length === 0) {
      return null;
    }
    const randomIndex = Math.floor(Math.random() * responses.length);
    return responses[randomIndex];
  }
  
  

  async findOneByService(serviceId: Types.ObjectId, path: string, method: string, statusCode: number): Promise<Response> {
    const query = { service: serviceId, path, method };
    
    if (statusCode) {
      query['statusCode'] = statusCode;
    }
    return (await this.responseModel.findOne(query).exec());
  }

  async findByService(serviceId: Types.ObjectId): Promise<Response[]> {
    return (await this.responseModel.find({ service: serviceId }).exec());
  }

  async delete(id: string) {
    const deletedCat = await this.responseModel
      .findByIdAndDelete({ _id: id })
      .exec();
    return deletedCat;
  }

  async deleteByService(serviceId: Types.ObjectId){
    const responses = await this.responseModel.find({ service: serviceId})
    responses.forEach( async res => {
      await this.responseModel.findByIdAndDelete(res._id)
    })
    return responses
  }

}
import { Injectable } from "@nestjs/common"
import { InjectModel } from "@nestjs/mongoose"
import { Model, Types } from "mongoose"
import { createServiceDto } from "src/dtos/createServiceDto"
import { Service } from "src/schemas/service.schema"
import { ResponseService } from "./response.service"
import { CreateResponseDto } from "src/dtos/createResponseDto"
import { MockerUtils, Parameter } from "src/utils/MockerUtils"
import { engine } from "src/utils/examples-engine/example-resolution-engine"
import { ExampleResolutionContext } from "src/utils/examples-engine/rules/rules.type"

@Injectable()
export class ServiceService {
  constructor(@InjectModel(Service.name) private readonly serviceModel: Model<Service>, private readonly responseService: ResponseService) {

  }

  async create(createServiceDto: createServiceDto): Promise<Service> {
    const createdService = await this.serviceModel.create(createServiceDto)
    return createdService
  }

  async findAll(): Promise<Service[]> {
    return this.serviceModel.find().select(["name", "version", "description", "openapi"])
  }

  async findAllForUser(userId: string): Promise<Service[]> {
    return this.serviceModel
      .find({
        $or: [{ owner: userId }, { collaborators: userId }],
      })
      .select(["name", "version", "description", "openapi", "owner", "collaborators"])
      .populate({path: "collaborators", select: "email username"})
      .populate('owner', ["email", "username"])
  }

  async findOne(id: string): Promise<Service> {
    return this.serviceModel.findOne({ _id: id }).exec()
  }

  async findOneByName(name: string): Promise<Service> {
    return await this.serviceModel.findOne({ name: name }).exec()
  }

  async findOneByNameAndVersion(name: string, version: string): Promise<Service> {
    return await this.serviceModel.findOne({ name, version }).populate({path: "collaborators", select: "email username"})
    .populate('owner', ["email", "username"])
    .exec()
  }

  async delete(id: Types.ObjectId) {
    const deletedCat = await this.serviceModel.findByIdAndDelete({ _id: id }).exec()
    return deletedCat
  }

  async createServiceResponses(createdService: Service) {
    const paths = createdService.openapi["paths"]
    const creationPromises = []

    // Iterate over all defined paths in the OpenAPI spec.
    for (const path in paths) {
      const methods = paths[path]
      for (const method in methods) {
        const operation = methods[method]

        // Generate a dynamic path by replacing any path parameters.
        const generatedPath = await MockerUtils.generatePath(
          path,
          Parameter.arrayFrom(operation.parameters, createdService.openapi),
          createdService.openapi,
        )

        // For each response code defined in the operation.
        const responseCodes = Object.keys(operation.responses)
        const responsePromises = responseCodes.map(async (code) => {
          // Build the context for our example resolution rules.
          const context: ExampleResolutionContext = {
            responseDefinition: operation.responses[code],
            openapi: createdService.openapi,
            operation: operation,
          }

          // Resolve the example(s) for the given response.
          const resolutionResult = await engine.resolve(context)

          // If a resolution result is returned, iterate over each example.
          if (resolutionResult && resolutionResult.examples.length > 0) {
            // For each example, create a separate response record.
            const recordPromises = resolutionResult.examples.map(async (example, index) => {
              const responseDto = {
                method,
                path: generatedPath,
                service: createdService._id,
                statusCode: Number.parseInt(code),
                content: example,
                // Save the example name if provided (e.g. from the MultipleExamplesRule)
                exampleName: resolutionResult.exampleNames ? resolutionResult.exampleNames[index] : null,
              } as CreateResponseDto
              return this.responseService.create(responseDto)
            })
            return Promise.all(recordPromises)
          } else {
            // Fallback: if no resolution result is available, create a response with an empty object.
            const fallbackDto = {
              method,
              path: generatedPath,
              service: createdService._id,
              statusCode: Number.parseInt(code),
              content: {},
              exampleName: "aiGenerated",
            } as CreateResponseDto
            return this.responseService.create(fallbackDto)
          }
        })
        creationPromises.push(Promise.all(responsePromises))
      }
    }
    await Promise.all(creationPromises)
  }
}


import { GeminiService } from "src/services/GeminiService";
import { AIServiceInterface } from "./AIServiceInterface";


export class AIServiceHandler {
    public static getAIService() : AIServiceInterface {
        const name = process.env['AI_SERVICE_NAME']
        switch(name) {
            case "gemini": return new GeminiService()
            default: throw new Error("please set AI_SERVICE_NAME environment variable to select an AI service to use")
        }
    }
}

export interface AIServiceInterface {
    ask(prompt: string) : any
}
import { IExampleRule, ExampleResolutionContext, ExampleResolutionResult } from "./rules/rules.type";
import { SingleExampleRule, MultipleExamplesRule, AIGenerationRule } from "./rules/single-example-rule";

/**
 * The engine that runs the chain of responsibility.
 * It accepts an ordered set of rules and processes the given context.
 * The AI generation rule should always be the last in the chain.
 */
class ExampleResolutionEngine {
    private chain: IExampleRule;

    constructor(rules: IExampleRule[]) {
        // It is assumed that the rules are provided in the order they should be executed.
        // Ensure that the last rule is the AI generation rule.
        rules.forEach((rule, index) => {
            if (index === rules.length - 1) {
                rule.setNext(null);
            } else {
                rule.setNext(rules[index + 1]);
            }
        })
        this.chain = rules[0];
    }

    /**
     * Runs the chain of rules until one rule returns a successful result.
     */
    public async resolve(context: ExampleResolutionContext): Promise<ExampleResolutionResult | null> {
        if (! this.chain) {
            return null;
        }
        // Start the chain with the first rule.
        return this.chain.handle(context);
    }
}
// Build the chain-of-responsibility engine.
export const engine = new ExampleResolutionEngine([
  new SingleExampleRule(),
  new MultipleExamplesRule(),
  new AIGenerationRule() // This rule is always last.
]);


/**
 * The context that will be passed to each example resolution rule.
 */
export interface ExampleResolutionContext {
    /**
     * The OpenAPI response definition for a specific response code.
     * This typically contains properties like `content`, which in turn may include
     * an `example`, an `examples` object, or a `schema` for fallback generation.
     */
    responseDefinition: any;
    
    /**
     * The full OpenAPI document.
     * This is needed for resolving any references (i.e., `$ref`) and to provide additional context.
     */
    openapi: any;
  
    /**
     * (Optional) Additional metadata, such as the operation details (path, method, etc.)
     */
    operation?: any;
  }
  

/**
 * The result of resolving an example.
 * It contains the example(s) and optionally the example names.
 */
export interface ExampleResolutionResult {
    // The resolved example content. For multiple examples, this array will contain each one.
    examples: any[];
    // Optionally, an array of example names (this may be used for the Response model update)
    exampleNames?: string[];
}

/**
 * The interface that all example resolution rules must implement.
 */
export interface IExampleRule {
    /**
     * Sets the next rule in the chain.
     */
    setNext(rule: IExampleRule): IExampleRule;
    /**
     * Attempts to handle the given context.
     * Returns a result if the rule applies, or null otherwise.
     */
    handle(context: ExampleResolutionContext): Promise<ExampleResolutionResult | null>;
}

/**
 * An abstract base class for example resolution rules.
 * It implements the chain logic: if a rule doesn't produce a result,
 * it passes the context to the next rule.
 */
export abstract class BaseExampleRule implements IExampleRule {
    private nextRule: IExampleRule;

    public setNext(rule: IExampleRule): IExampleRule {
        this.nextRule = rule;
        return rule;
    }

    public async handle(context: ExampleResolutionContext): Promise<ExampleResolutionResult | null> {
        const result = await this.process(context);
        if (result !== null) {
            // If the current rule produced a result, return it and break the chain.
            return result;
        }
        // Otherwise, delegate to the next rule if it exists.
        if (this.nextRule) {
            return this.nextRule.handle(context);
        }
        return null;
    }

    /**
     * Process the context to try to resolve an example.
     * Return a valid ExampleResolutionResult if successful, or null if not.
     */
    protected abstract process(context: ExampleResolutionContext): Promise<ExampleResolutionResult | null>;
}
// concrete-example-rules.ts

import { BaseExampleRule, ExampleResolutionContext, ExampleResolutionResult } from './rules.type';
import { MockerUtils } from 'src/utils/MockerUtils';

/**
 * Rule that checks for a single defined example.
 * It looks for the 'example' property in the response content.
 */
export class SingleExampleRule extends BaseExampleRule {
  protected async process(context: ExampleResolutionContext): Promise<ExampleResolutionResult | null> {
    const content = context.responseDefinition?.content?.['application/json'];
    if (content && content.example) {
      // Found a single example. Return it as a one-element array.
      return {
        examples: [content.example],
        exampleNames: ['default']
      };
    }
    return null;
  }
}

/**
 * Rule that checks for multiple defined examples.
 * It looks for the 'examples' property and extracts all example values and their names.
 */
export class MultipleExamplesRule extends BaseExampleRule {
  protected async process(context: ExampleResolutionContext): Promise<ExampleResolutionResult | null> {
    const content = context.responseDefinition?.content?.['application/json'];
    if (content && content.examples) {
      const examples: any[] = [];
      const exampleNames: string[] = [];
      
      // Iterate over each example defined in the examples object.
      for (const key in content.examples) {
        if (content.examples.hasOwnProperty(key)) {
          let value = content.examples[key];
          // If the example is defined via a $ref, resolve it.
          if (value.$ref) {
            value = MockerUtils.resolveRef(value.$ref, context.openapi);
            // Some references wrap the value in a 'value' property.
            if (value && value.value) {
              value = value.value;
            }
          } else if (value.value) {
            // If it's an object with a 'value' property, use that.
            value = value.value;
          }
          examples.push(value);
          exampleNames.push(key);
        }
      }
      if (examples.length > 0) {
        return {
          examples,
          exampleNames
        };
      }
    }
    return null;
  }
}

/**
 * Fallback rule that uses AI generation to generate an example.
 * This rule is always the last in the chain.
 */
export class AIGenerationRule extends BaseExampleRule {
  protected async process(context: ExampleResolutionContext): Promise<ExampleResolutionResult | null> {
    const content = context.responseDefinition?.content?.['application/json'];
    if (content && content.schema) {
      try {
        // Always use AI generation if we reach this rule.
        const aiExample = await MockerUtils.generateExampleWithAI(content.schema, context.openapi, context.operation);
        return {
          examples: [aiExample],
          exampleNames: ['aiGenerated']
        };
      } catch (error) {
        console.error("AI Generation failed:", error);
        // Optionally, return a fallback empty object.
        return {
          examples: [{}],
          exampleNames: ['fallback']
        };
      }
    }
    // If no schema is provided, fallback with an empty example.
    return {
      examples: [{}],
      exampleNames: ['fallback']
    };
  }
}

import { ApiProperty } from "@nestjs/swagger"

export class MockerResponse{
    @ApiProperty()
    status: number
    @ApiProperty()
    message: any

    public constructor(status: number, message: any){
        this.status = status
        this.message = message
    }
}
// Updated MockerUtils.ts
import { faker } from '@faker-js/faker';
import { randomInt } from 'crypto';
import { GeminiService } from 'src/services/GeminiService';
import { AIServiceHandler } from './AIServiceHandler';



export class Parameter {
    name: string
    schema: object
    example: any

    constructor(name: string, schema: object, example: any) {
        this.name = name
        this.schema = schema
        this.example = example
    }

    public static arrayFrom(parameters: any[], openapi: object) {
        if (parameters) {
            parameters.forEach((p, index) => {
                if (Object.keys(p).includes("$ref")) {
                    parameters[index] = MockerUtils.resolveRef(p['$ref'], openapi)
                }
            })
            return parameters.filter(param => param.in == "path").map((param) => new Parameter(param.name, param.schema, param['example']))
        }
        else return []
    }
}

export class MockerUtils {
    // Cache for resolved $ref values to improve performance
    private static refCache = {};

    public static resolveRef(refString: string, rootDoc: any): any {
        if (this.refCache[refString]) {
            return this.refCache[refString];
        }
        const path = refString.split('/');
        path.shift(); // Remove the leading "#"
        let currentObject = rootDoc;
        for (const key of path) {
            currentObject = currentObject[key];
            if (!currentObject) {
                throw new Error(`Failed to resolve reference: ${refString}`);
            }
        }
        this.refCache[refString] = currentObject;
        return currentObject;
    }

    public static resolveRefs(obj: any, rootDoc: any): any {
        if (typeof obj !== 'object' || obj === null) {
            return obj; // Base case: not an object
        }
        if (Array.isArray(obj)) {
            return obj.map(item => this.resolveRefs(item, rootDoc));
        }
        const resolvedObj = {};
        for (const key in obj) {
            const value = obj[key];
            if (key === "$ref") {
                Object.assign(resolvedObj, this.resolveRefs(this.resolveRef(value, rootDoc), rootDoc));
            } else {
                resolvedObj[key] = this.resolveRefs(value, rootDoc);
            }
        }
        return resolvedObj;
    }

    public static fetchDefinedExample(examples: any, openapi: any): any {
        const firstKey = Object.keys(examples)[0];
        const firstExample = examples[firstKey];
        return (Object.keys(firstExample).includes("$ref"))
            ? this.resolveRef(firstExample["$ref"], openapi)["value"]
            : firstExample;
    }

    public static async generateExampleWithAI(schema: any, openapi: any, operation?: any): Promise<any> {
        if (!schema) return {};
        const aiService = AIServiceHandler.getAIService();
        const resolvedSchema = this.resolveRefs(schema, openapi);
    
        // Extract API context from the OpenAPI document (e.g. title and description)
        const apiTitle = openapi.info?.title || 'API';
        const apiDescription = openapi.info?.description || '';
    
        // Extract the operation description, if available
        const operationDescription = operation?.description || '';
    
        // Build a prompt that includes both the API and operation context
        const prompt = `I want to generate an OpenAPI response example for an endpoint of the "${apiTitle}".
    Please generate an example that fits the context of this API.
    API Description: ${apiDescription}
    Operation Description: ${operationDescription}
    Do not add any attributes that are not defined in the schema below.
    Here is the schema definition:
    ${JSON.stringify(resolvedSchema, null, 4)}
    Provide only the generated example as response.`;
    
        try {
            return await aiService.ask(prompt);
        } catch (error) {
            throw error;
        }
    }
    

    public static async generatePathWithAi(path: string, param: any, openapi: any): Promise<any> {
        param.schema = Object.keys(param.schema).includes("$ref")
            ? this.resolveRef(param.schema["$ref"], openapi)
            : param.schema;
        const aiService = new GeminiService();
        const prompt = `I want you to generate an example value for my path param: ${param.name} used in this OpenAPI path: ${path}. Return only the generated value.`;
        return await aiService.ask(prompt);
    }

    // Helper to generate realistic values for known formats
    private static getFakerValueForFormat(schema: any): any {
        switch (schema.format) {
            case 'date-time':
                return faker.date.recent().toISOString();
            case 'email':
                return faker.internet.email();
            case 'url':
                return faker.internet.url();
            case 'uuid':
                return faker.string.uuid();
            default:
                return null;
        }
    }

    public static generateExample(schema: any, openapi: any): any {
        if (!schema) return {};
        schema = Object.keys(schema).includes("$ref")
            ? this.resolveRef(schema["$ref"], openapi)
            : schema;

        // If a specific format is provided, use it to generate a realistic value.
        if (schema.format) {
            const formatValue = this.getFakerValueForFormat(schema);
            if (formatValue !== null) return formatValue;
        }

        if (Object.keys(schema).includes("allOf")) {
            return this.generateAllOfExample(schema["allOf"], openapi);
        }
        if (Object.keys(schema).includes("oneOf")) {
            const randomIndex = randomInt(schema["oneOf"].length);
            return this.generateExample(schema["oneOf"][randomIndex], openapi);
        }
        // Handle schema types
        switch (schema.type) {
            case 'string':
                return schema.enum ? schema.enum[0] : faker.person.firstName();
            case 'number':
                return schema.enum ? schema.enum[0] : faker.number.float() * 10;
            case 'integer':
                return schema.enum ? schema.enum[0] : faker.number.int();
            case 'boolean':
                return schema.enum ? schema.enum[0] : faker.datatype.boolean();
            case 'array':
                return this.generateArrayExample(schema.items, openapi);
            case 'object':
                return Object.assign(
                    {},
                    schema.properties ? this.generateObjectExample(schema.properties, openapi) : {},
                    schema["additionalProperties"] ? this.generateExample(schema["additionalProperties"], openapi) : {}
                );
            default:
                throw new Error(`Unsupported schema type: ${schema.type}`);
        }
    }

    public static generateAllOfExample(allOfSchema: any[], openapi: any): any {
        const resultExample = {};
        allOfSchema.forEach(element => {
            Object.assign(resultExample, this.generateExample(element, openapi));
        });
        return resultExample;
    }

    public static generateArrayExample(itemSchema: any, openapi: any): any {
        const exampleArray = [];
        for (let i = 0; i < 3; i++) {
            exampleArray.push(this.generateExample(itemSchema, openapi));
        }
        return exampleArray;
    }

    public static generateObjectExample(properties: any, openapi: any): any {
        const exampleObject = {};
        for (const [key, propSchema] of Object.entries(properties)) {
            exampleObject[key] = this.generateExample(propSchema, openapi);
        }
        return exampleObject;
    }

    public static async generatePath(path: string, parameters: any[], openapi: any): Promise<string> {
        if (!parameters.length) return path;
        const pathArray = path.split("/");
        for (let index = 0; index < pathArray.length; index++) {
            const part = pathArray[index];
            if (part.startsWith('{') && part.endsWith('}')) {
                const param = parameters.filter(param => param.name === part.slice(1, -1))[0];
                if (param.example)
                    pathArray[index] = param.example;
                else if (param.schema["default"])
                    pathArray[index] = param.schema["default"];
                else if (process.env['AI_GENERATION_ENABLED'] === "true")
                    pathArray[index] = await this.generatePathWithAi(path, param, openapi);
                else
                    pathArray[index] = this.generateExample(param.schema, openapi);
            }
        }
        return pathArray.join("/");
    }
}

